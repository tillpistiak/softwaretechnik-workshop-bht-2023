# TEST

## Table of Contents
- [TEST](#test)
  - [Table of Contents](#table-of-contents)
  - [jUnit: RestAssured](#junit-restassured)
    - [Configuration](#configuration)
  - [Derby](#derby)
    - [Configuration](#configuration-1)
  - [Integration into build pipeline](#integration-into-build-pipeline)
  - [Coverage: JaCoCo](#coverage-jacoco)
    - [Configuration](#configuration-2)

## jUnit: RestAssured
*JUnit and RestAssured are two distinct, yet complementary libraries used in Java for testing purposes.*

*JUnit is a renowned testing framework for Java applications. It is primarily used for unit testing, which is the process of testing the smallest testable parts of your application, such as methods and classes. JUnit provides a set of annotations to identify test methods and contains assertions to test expected results.*

*On the other hand, RestAssured is a Java library specifically designed for testing RESTful APIs. It provides a domain-specific language (DSL) that allows you to write powerful, maintainable tests for your APIs.* (ChatGPT) 

### Configuration
1. add dependencies to pom.xml<br>
   To allow automated testing on GitHub Actions & locally without further configuration we decided to use an in-memory derby db for the tests. 
   ```xml
    <dependency>
      <groupId>io.quarkus</groupId>
      <artifactId>quarkus-junit5</artifactId>
      <scope>test</scope>
    </dependency>
    <dependency>
      <groupId>io.rest-assured</groupId>
      <artifactId>rest-assured</artifactId>
      <scope>test</scope>
    </dependency>
   ```
2. annotate test classes with `@QuarkusTest`
3. write test cases in RestAssured dialect
   ```java
   given()
      .when()
        .get("/appointments")
      .then()
        .statusCode(200)
        .body("", hasSize(0));
   ```

## Derby
*Derby is a lightweight, open-source relational database management system (RDBMS) written in Java. It is often used as an embedded database within Java applications. Derby is known for its simplicity, ease of use, and small footprint, making it a popular choice for small to medium-sized projects.* (GitHub Copilot)

To allow automated testing on GitHub Actions & locally without further configuration we decided to use an in-memory derby db for the tests. For the tests its sufficient to have the DDL generated by Hibernate and not by Liquibase.

### Configuration
1. add dependencies to pom.xml<br>
   ```xml
    <dependency>
      <groupId>io.quarkus</groupId>
      <artifactId>quarkus-jdbc-derby</artifactId>
    </dependency>
    <dependency>
      <groupId>io.quarkus</groupId>
      <artifactId>quarkus-test-derby</artifactId>
      <scope>test</scope>
    </dependency>
    <dependency>
      <groupId>io.quarkus</groupId>
      <artifactId>quarkus-jdbc-derby</artifactId>
    </dependency>
   ```
2. configure derby in application.properties
   ```properties   
   quarkus.datasource.db-kind=derby
   quarkus.datasource.jdbc.url=jdbc:derby://localhost:1527/memory:testDB;create=true;NON_KEYWORDS=USER
   quarkus.package.write-transformed-bytecode-to-build-output=true
   quarkus.liquibase.migrate-at-start=true
   quarkus.hibernate-orm.database.generation=drop-and-create
   ```
3. annotate tests with `@QuarkusTestResource(DerbyDatabaseTestResource.class)`

## Integration into build pipeline
To automatically run the tests on every push to the remote repository, we created a Github Actions Pipeline "test".
The pipline runs the command 
```bash
mvn verify
```
which executes all tests and checks potential rules.

## Coverage: JaCoCo
*JaCoCo, short for Java Code Coverage, is an open-source toolkit used for measuring test coverage in Java applications.*

*It allows developers to analyze the extent to which their tests cover the source code by tracking which parts of the code are executed during test runs. JaCoCo generates reports providing detailed information on covered and uncovered code lines, branches, methods, and classes.*

*Test coverage serves as a metric to assess how well the source code is tested, aiding developers in identifying areas that lack coverage and improving the overall software quality. It is commonly employed in Continuous Integration and Continuous Delivery pipelines to ensure that code changes do not adversely impact test coverage.* (ChatGPT)

### Configuration
1. configure JaCoCo maven plugin https://quarkus.io/guides/tests-with-coverage
3. add coverage to test pipeline
4. if configured as described in the tutorial, `mvn verify` will automatically run with JaCoCo Coverage enabled. Should the defined limits not be met, the pipeline will fail.